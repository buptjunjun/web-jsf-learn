package com.junjun.algorithm.charpter13;
import java.util.*;
import java.util.Map.Entry;

import com.junjun.algorithm.charpter12.BinarySearchTree;
import com.junjun.algorithm.charpter5.RandomArray;
import com.junjun.algorithm.charpter8.QuickSort;

/**
 * 红黑树:
 * 红黑树是一种二叉查找树,不同点是，对于每一个节点都有一种颜色：红色或者黑色,通过对根到叶子节点的路径上的各个节点着色方式的限制，
 * 红黑树可以保证：每一一条路径比其他一条路径长2倍，所以树是接近平衡的。
 * 一棵二叉查找树满足下面性质叫做红黑树：
 * 1 每一个节点是红的或者黑的
 * 2 根节点是黑的
 * 3 叶节点是黑的
 * 4 如果一个节点是红的其两个儿子是黑的
 * 5 每个节点 到其每一个子孙节点路径上有相同数据的黑节点。
 * 
 * 平衡二叉树(AVL)与红黑树(RBT)
 * 平衡二叉树的追求的是全局均衡，如在做插入，删除操作时，需要调整整棵树，显然这是费时的，因此希望在做调整时，是局部调整，因此提出了红黑树，这样一种高效的数据结构(也是最变态的一种数据结构)
 */

public class RBTree
{
	public Node root = null;
	static public boolean RED = true;
	static public boolean BLACK = false;
	private Node NIL = new Node(Integer.MAX_VALUE,BLACK);
	
	//二叉树的一个节点
	class Node
	{
		public boolean color = RED;
		public int data = 0;       //数据
		public Node p = null;       //父亲
		public Node lchild = null;  //左孩子
		public Node rchild = null;  //右孩子
		
		public Node(int data,boolean color)
		{
			// TODO Auto-generated constructor stub
			this.data = data;
		}
	}
	
	/**
	 * 创建一棵二叉查找树
	 * @param datas
	 * @return
	 */
	public void createTree(int [] datas)
	{
		this.root = null;
		for(int i = 0;i < datas.length;i++)
		{		
			this.insertNode(datas[i]);
		}
	}
	
	/**
	 * 返回树的高度
	 * @param node
	 * @return
	 */
	public int height(Node node)
	{
		if(node == null)
			return 0;
		int hl = height(node.lchild);
		int hr = height(node.rchild);
		if(hl < hr)
			return hr+1;
		else return hl+1;
	}
	
	/**
	 * 删除树
	 */
	public void clear()
	{
		while(this.root != null)
			this.deleteNode(root);
	}
	
	
	
	private Node searchInsertPos(int data)
	{
		//如果树为空 node直接作为树根
		if(this.root == null)		
			return null;
		
		//查找插入点
		Node cur = this.root;
		Node pre = this.root;
		while(true)
		{
			pre = cur;
			if(data < cur.data)
				cur = cur.lchild;
			else if(data > cur.data)
				cur = cur.rchild;
			else  //每一个node都不能相同
				return null;
			
			//找到了插入位置
			if(cur == this.NIL)
			{
				return pre;
			}	
		}
	}
	
	/**
	 * 查找值为data的节点
	 * @param data
	 * @return null 如果没有找到，否则返回这个节点
	 */
	public Node search(int data)
	{
		Node cur = this.root;
		while(cur!=null)
		{
			if(data < cur.data)
				cur = cur.lchild;
			else if(data > cur.data)
				cur = cur.rchild;
			else  
				break;
		}
		return cur;
	}
	
	
	/**
	 * 往一棵二叉查找树中插入一个节点
	 * @param node
	 * @return
	 */
	public Node insertNode(int data)
	{
		//如果树为空 node直接作为树根
		if(this.root == null)
		{
			this.root = new Node(data,RED);
			this.root.rchild = NIL;
			this.root.lchild = NIL;
			this.root.p = NIL;
			
			return this.root;
		}
		
		Node insertNode = searchInsertPos(data);
		if(insertNode == null)
			return null;
		else
		{
			Node n = new  Node(data,RED);
			n.lchild = this.NIL;
			n.rchild = this.NIL;
			if(data < insertNode.data) //如果比插入点小,插入到左孩子
			{
				insertNode.lchild = n;
				n.p = insertNode;
			}
			else if(data > insertNode.data) //如果比插入点大,插入到右孩子
			{
				insertNode.rchild = n;
				n.p = insertNode;
			}
			else  //插入失败
				return null;
			return n;
		}		
	}
	
	/**
	 * 找一棵树的最小值
	 * @param node 根节点
	 * @return
	 */
	public Node min(Node node)
	{
		while(node.lchild !=null)
			node = node.lchild;
		return node;
	}
	
	/**
	 * 找一棵树的最大值 
	 * @param node 根节点
	 * @return
	 */
	public Node max(Node node)
	{
		while(node.rchild !=null)
			node = node.rchild;
		return node;
	}
	
	/**
	 * 找node的后继(中序)
	 */
	public Node successor(Node node)
	{
		if(node.rchild == null)
		{
			return null;
		}
		
		Node rchild = node.rchild;
		Node successor = this.min(rchild);
		return successor;
	}
	
	
	/**
	 * 找node的前驱(中序)
	 */
	public Node predecessor(Node node)
	{
		if(node.lchild == null)
		{
			return null;
		}
		
		Node lchild = node.lchild;
		Node predecessor = this.max(lchild);
		return predecessor;
	}
	
	/**
	 * 删除一个节点
	 * @param data
	 * @return
	 */
	public boolean deleteNode(int data)
	{
		Node node = search(data);
		if(node == null)
			return false;
		
		return this.deleteNode(node);
	}
	

	/**
	 * 右旋转
	 * @param node
	 */
	public void RRotate(Node node)
	{
		Node parent = node.p;	
		Node lchild_node = node.lchild;
		Node rlchild_node = lchild_node.rchild;
		
		node.lchild = rlchild_node;
		lchild_node.rchild = node;
		
		if(parent.rchild == node)
			parent.rchild = lchild_node;
		else parent.lchild = lchild_node;
	}
	
	/**
	 * 左旋转
	 * @param node
	 */
	public void LRotate(Node node)
	{
		Node parent = node.p;
		Node rchild_node = node.rchild;
		Node lrchild_node = rchild_node.lchild;
		
		node.rchild = lrchild_node;
		rchild_node.lchild = node;
		
		if(parent.rchild == node)
			parent.rchild = rchild_node;
		else parent.lchild = rchild_node;
	}
	
	/**
	 * 删除一个节点
	 * 有三种情况
	 * 1,该节点左右子都是空:直接删除
	 * 2,一个孩子为空,一个孩子不为空:
	 * 3,左右子都不为空：删除该节点的后继，用后继(中序遍历)替换要删除的节点
	 * @param node
	 * @return
	 */
	private boolean deleteNode(Node node)
	{
		//如果树为空 node直接作为树根
		if(this.root == null)
		{
			return false;
		}
		
		//先查找是否在树中
		if(node == null)
			return false;
		Node parent = node.p;

		//左右子树都为空 叶子节点
		if(node.lchild == null && node.rchild == null)
		{
			//只有一个元素 且是根
			if(parent == null)
				this.root = null;
			else
			{
				//如果是左儿子
				if(node.data < parent.data)
				{
					parent.lchild = null;
				}
				else
				{
					parent.rchild = null;
				}
			}
			node.p = null;
		}
		else if(node.lchild != null && node.rchild == null) //左子不为空 右子为空
		{
			//如果删除的是根
			if(parent == null)
				this.root = node.lchild;
			else
			{
				//如果是左儿子
				if(node.data < parent.data)
				{
					parent.lchild = node.lchild;
				}
				else
				{
					parent.rchild = node.lchild;
				}
			}
			node.p = null;
		}		
		else if(node.lchild == null && node.rchild != null) //左子为空 右子不为空
		{
			//如果删除的是根
			if(parent == null)
				this.root = node.rchild;
			else
			{
				//如果是左儿子
				if(node.data < parent.data)
				{
					parent.lchild = node.rchild;
				}
				else
				{
					parent.rchild = node.rchild;
				}
			}
			node.p = null;
		}
		else  //左右子都不为空 找当前node的后继，
		{
			//找到 node的后继
			Node successor = this.successor(node);
			//删除后继
			this.deleteNode(successor);
			//用后继来替换当前待删除的node
			node.data = successor.data;
		}
		
		return true;
				
	}
	
	/**
	 * 先序打印一棵树
	 */
	public void print(Node node)
	{
		if(node == NIL)
			return;
		System.out.print (node.data+" ");
		print(node.lchild);
		print(node.rchild);
	}
	
	public static void main(String [] args)
	{	
		int [] test = {4,2,1,3,6,5,7};
		RBTree rbt = new RBTree();

		/*打印一棵树
		 *                  4  
		 *               2		6
		 *             1   3  5   7
		 */
		rbt.createTree(test);
		rbt.print(rbt.root);
		
		//max and min
		System.out.println("max = "+rbt.max(rbt.root).data);
		System.out.println("min = "+rbt.min(rbt.root).data);
		
		//search
		Node node = rbt.search(4);
		System.out.println("search = "+ node.data);
		
		//左旋  
		System.out.println("左旋");
		rbt.LRotate(node);
		rbt.print(rbt.root);
		
		//右旋
		node = rbt.search(7);
		System.out.println("\n右旋");
		rbt.RRotate(node);
		rbt.print(rbt.root);

		
		
		
	}
}
