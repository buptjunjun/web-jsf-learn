
<html>
<head>   
 <title>Hello World jQuery!</title>   
 <style type="text/css">
 a.test{ font-weight: bold; background-color:blue;}
 </style>
 
 </style>

 <script type="text/javascript" > 
 
    //定义一个类
    function Car(sColor, sDriver)
	{
	    this.color = sColor;
		this.driver = new Array("mike","susan");
		
		//这样只会调用创建一个 showColor对象，节约内存
		if(typeof Car._intialized == "undefined")
		{
			//prototype用于创建方法
			Car.prototype.showColor = function()
			{
				alert(this.color);
			}
			Car._intialized = true;
		}
	}
	
	function func()
	{
		car1 = new Car("red");
		car2 = new Car("blue");
		
		car1.driver.push("andy");
		car1.showColor();
		car2.showColor();
		
		alert(car1.driver);
		alert(car2.driver);
		
		alert(car1.constructor);
	}
	
	// func();
	
	//继承
	function ClassA(sColor)
	{
		this.color = sColor;
		this.sayColor = function ()
		{
			alert(this.color);
		}
	}
	
	
	//继承自ClassA 使用 对象冒充
 	function ClassB(sColor, sName)
	{
		this.newMethod = ClassA;
		this.newMethod(sColor);
		delete this.newMethod;
		
		this.name = sName;
		this.sayName = function()
		{
			alert(this.name);
		}
	} 
	
	//继承自ClassA 使用Call函数
 	function ClassB(sColor, sName)
	{
		/* this.newMethod = ClassA;
		this.newMethod(sColor);
		delete this.newMethod; */
		
		this.name = sName;
		this.sayName = function()
		{
			alert(this.name);
		}
	} 
	
	//使用原型链
 	function ClassC(){};
	
	ClassB.prototype = new ClassA();
	ClassB.prototype.name="--";
	ClassB.prototype.sayName = function()
	{
		alert(this.name);
	}; 
	
	var objA = new ClassA("blue");
	var objB = new ClassB();
/* 	objB.color="red";
	objB.name="yang";
	
	objA.sayColor();
	objB.sayColor();
	objB.sayName();  */
	

	
	
/* 	var objA = new ClassA("blue");
	var objB = new ClassB("red","Andy");
	
	objA.sayColor();
	objB.sayColor();
	objB.sayName(); */
	
	
 </script>
 </head>
 
 <body>   
 
	